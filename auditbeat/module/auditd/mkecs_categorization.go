// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// +build ignore

package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

type messageType struct {
	CategoriesString string   `yaml:"-"`
	TypesString      string   `yaml:"-"`
	Categories       []string `yaml:"categories"`
	Types            []string `yaml:"types"`
}

type eventType struct {
	CategoriesString   string              `yaml:"-"`
	DefaultTypesString string              `yaml:"-"`
	TypeStrings        map[string]string   `yaml:"-"`
	Categories         []string            `yaml:"categories"`
	DefaultTypes       []string            `yaml:"default_types"`
	Types              map[string][]string `yaml:"types"`
}

// TemplateParams is the data used in evaluating the template.
type TemplateParams struct {
	Command      string                 `yaml:"-"`
	EventTypes   map[string]eventType   `yaml:"eventTypes"`
	MessageTypes map[string]messageType `yaml:"messagetypes"`
}

const fileTemplate = `
// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by {{.Command}} - DO NOT EDIT.

package auditd

import (
	"github.com/elastic/go-libaudit/auparse"
	"github.com/elastic/go-libaudit/aucoalesce"
)

type ecsCategorizationFields struct {
	Categories []string
	Types      []string
}

type nestedCategorizationFields struct {
	Categories []string
	DefaultTypes []string
	Types map[auparse.AuditMessageType][]string
}

var ecsAuditdCategories = map[aucoalesce.AuditEventType]nestedCategorizationFields{
{{- range $name, $eventType := .EventTypes }}
	aucoalesce.{{ $name }}: nestedCategorizationFields{
		Categories: []string{ {{ $eventType.CategoriesString }} },
		DefaultTypes: []string{ {{ $eventType.DefaultTypesString }} },
		Types: map[auparse.AuditMessageType][]string{
		{{- range $type, $messageType := $eventType.TypeStrings }}
			auparse.{{ $type }}: []string{ {{ $messageType }} },
		{{- end }}
		},
	},
{{- end }}
}

var ecsAuditdCategoryOverrides = map[auparse.AuditMessageType]ecsCategorizationFields{
{{- range $name, $messageType := .MessageTypes }}
	auparse.{{ $name }}: ecsCategorizationFields{ 
		Categories: []string{ {{ $messageType.CategoriesString }} },
		Types: []string{ {{ $messageType.TypesString }} },
	},
{{- end }}
}

func getECSCategorization(eventType aucoalesce.AuditEventType, messageType auparse.AuditMessageType) ecsCategorizationFields {
	if found, ok := ecsAuditdCategoryOverrides[messageType]; ok {
		return found
	}
	if found, ok := ecsAuditdCategories[eventType]; ok {
		var types []string
		if mappedTypes, ok := found.Types[messageType]; ok {
			types = mappedTypes
		} else {
			types = found.DefaultTypes
		}
		return ecsCategorizationFields{
			Categories: found.Categories,
			Types: types,
		}
	}

	return ecsCategorizationFields{}
}
`

var tmpl = template.Must(template.New("message_types").Parse(fileTemplate))

func fillMessageTypes(schema map[string]messageType) {
	for name, message := range schema {
		categoryStrings := []string{}
		typeStrings := []string{}
		for _, category := range message.Categories {
			categoryStrings = append(categoryStrings, fmt.Sprintf("\"%s\"", category))
		}
		for _, typeString := range message.Types {
			typeStrings = append(typeStrings, fmt.Sprintf("\"%s\"", typeString))
		}
		message.CategoriesString = strings.Join(categoryStrings, ", ")
		message.TypesString = strings.Join(typeStrings, ", ")
		schema[name] = message
	}
}

func fillEventTypes(schema map[string]eventType) {
	for name, event := range schema {
		categoryStrings := []string{}
		defaultTypeStrings := []string{}
		for _, category := range event.Categories {
			categoryStrings = append(categoryStrings, fmt.Sprintf("\"%s\"", category))
		}
		for _, typeString := range event.DefaultTypes {
			defaultTypeStrings = append(defaultTypeStrings, fmt.Sprintf("\"%s\"", typeString))
		}
		event.CategoriesString = strings.Join(categoryStrings, ", ")
		event.DefaultTypesString = strings.Join(defaultTypeStrings, ", ")
		typeStrings := make(map[string]string, len(event.Types))
		for name, messageType := range event.Types {
			types := []string{}
			for _, typeString := range messageType {
				types = append(types, fmt.Sprintf("\"%s\"", typeString))
			}
			typeStrings[name] = strings.Join(types, ", ")
		}
		event.TypeStrings = typeStrings
		schema[name] = event
	}
}

func run() error {
	// Open input file.
	in, err := os.Open(flagIn)
	if err != nil {
		return err
	}
	defer in.Close()

	inData, err := ioutil.ReadAll(in)
	if err != nil {
		return err
	}

	params := TemplateParams{
		Command: filepath.Base(os.Args[0]),
	}
	if err := yaml.Unmarshal(inData, &params); err != nil {
		return err
	}
	fillEventTypes(params.EventTypes)
	fillMessageTypes(params.MessageTypes)

	f, err := os.Create(flagOut)
	if err != nil {
		return err
	}
	if err := tmpl.Execute(f, params); err != nil {
		f.Close()
		return err
	}
	f.Close()

	if _, err := exec.Command("go", "fmt", flagOut).Output(); err != nil {
		return nil
	}

	return nil
}

var flagIn string
var flagOut string

func main() {
	flag.StringVar(&flagIn, "in", "ecs_categorization.yml", "input file")
	flag.StringVar(&flagOut, "out", "zecs_categorization.go", "output file")
	flag.Parse()

	var err error
	flagIn, err = filepath.Abs(flagIn)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
	flagOut, err = filepath.Abs(flagOut)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}
