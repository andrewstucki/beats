// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

// Min and max record/message numbers.
const (
	minRecordNum = 1000
	maxRecordNum = 3000
)

type categorizationFields struct {
	Name             string   `yaml:"-"`
	CategoriesString string   `yaml:"-"`
	TypesString      string   `yaml:"-"`
	Categories       []string `yaml:"categories"`
	Types            []string `yaml:"types"`
}

// TemplateParams is the data used in evaluating the template.
type TemplateParams struct {
	Command        string
	FieldsByNumber map[int]categorizationFields
}

const fileTemplate = `
// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by {{.Command}} - DO NOT EDIT.

package auditd

import (
	"github.com/elastic/go-libaudit/aucoalesce"
)

type ecsCategorizationFields struct {
	Categories []string
	Types      []string
}

var ecsAuditdCategories = map[aucoalesce.AuditMessageType]ecsCategorizationFields{
{{- range $recordNum, $recordType := .FieldsByNumber }}
	auocoalesce.{{ $recordType.Name }}: ecsCategorizationFields{ // {{ $recordNum }}
		Categories: []string{ {{ $recordType.CategoriesString }} },
		Types: []string{ {{ $recordType.TypesString }} },
	},
{{- end }}
}

func getECSCategorization(messageType aucoalesce.AuditMessageType) ecsCategorizationFields {
	if found, ok := ecsAuditdCategories[messageType]; ok {
		return found
	}
	return ecsCategorizationFields{}
}
`

var tmpl = template.Must(template.New("message_types").Parse(fileTemplate))

var (
	headers = []string{
		`https://raw.githubusercontent.com/torvalds/linux/v4.16/include/uapi/linux/audit.h`,
		`https://raw.githubusercontent.com/linux-audit/audit-userspace/4d933301b1835cafa08b9e9ef705c8fb6c96cb62/lib/libaudit.h`,
		`https://raw.githubusercontent.com/linux-audit/audit-userspace/4d933301b1835cafa08b9e9ef705c8fb6c96cb62/lib/msg_typetab.h`,
	}
)

func DownloadFile(url, destinationDir string) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("http get failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("download failed with http status %v", resp.StatusCode)
	}

	name := filepath.Join(destinationDir, filepath.Base(url))
	f, err := os.Create(name)
	if err != nil {
		return "", fmt.Errorf("failed to create output file: %v", err)
	}

	_, err = io.Copy(f, resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to write file to disk: %v", err)
	}

	return name, nil
}

var (
	// nameMappingRegex is used to parse name mappings from msg_typetab.h.
	nameMappingRegex = regexp.MustCompile(`^_S\((AUDIT_\w+),\s+"(\w+)"`)

	// recordTypeDefinitionRegex is used to parse type definitions from audit
	// header files.
	recordTypeDefinitionRegex = regexp.MustCompile(`^#define\s+(AUDIT_\w+)\s+(\d+)`)
)

func readMessageTypeTable() (map[string]string, error) {
	f, err := os.Open("msg_typetab.h")
	if err != nil {
		return nil, err
	}
	defer f.Close()

	constantToStringName := map[string]string{}
	s := bufio.NewScanner(f)
	for s.Scan() {
		matches := nameMappingRegex.FindStringSubmatch(s.Text())
		if len(matches) == 3 {
			constantToStringName[matches[1]] = matches[2]
		}
	}

	return constantToStringName, nil
}

func readRecordTypes() (map[string]int, error) {
	out, err := exec.Command("gcc", "-E", "-dD", "libaudit.h", "audit.h").Output()
	if err != nil {
		return nil, err
	}

	recordTypeToNum := map[string]int{}
	s := bufio.NewScanner(bytes.NewReader(out))
	for s.Scan() {
		matches := recordTypeDefinitionRegex.FindStringSubmatch(s.Text())
		if len(matches) != 3 {
			continue
		}
		recordNum, _ := strconv.Atoi(matches[2])

		// Filter constants.
		if recordNum >= minRecordNum && recordNum <= maxRecordNum {
			recordTypeToNum[matches[1]] = recordNum
		}
	}

	return recordTypeToNum, nil
}

func categorizationFieldFor(recordType string, schema map[string]categorizationFields) categorizationFields {
	if found, ok := schema[recordType]; ok {
		categoryStrings := []string{}
		typeStrings := []string{}
		for _, category := range found.Categories {
			categoryStrings = append(categoryStrings, fmt.Sprintf("\"%s\"", category))
		}
		for _, typeString := range found.Types {
			typeStrings = append(typeStrings, fmt.Sprintf("\"%s\"", typeString))
		}
		return categorizationFields{
			Name:             recordType,
			CategoriesString: strings.Join(categoryStrings, ", "),
			TypesString:      strings.Join(typeStrings, ", "),
		}
	}
	return categorizationFields{
		Name: recordType,
	}
}

func run() error {
	// Open input file.
	in, err := os.Open(flagIn)
	if err != nil {
		return err
	}
	defer in.Close()

	inData, err := ioutil.ReadAll(in)
	if err != nil {
		return err
	}

	schema := make(map[string]categorizationFields)
	if err := yaml.Unmarshal(inData, &schema); err != nil {
		return err
	}

	tmp, err := ioutil.TempDir("", "mk_audit_msg_types")
	if err != nil {
		return err
	}
	defer os.RemoveAll(tmp)

	// Download header files from the Linux audit project.
	var files []string
	for _, url := range headers {
		f, err := DownloadFile(url, tmp)
		if err != nil {
			return fmt.Errorf("download failed for %v: %v", url, err)
		}
		files = append(files, f)
	}

	if err := os.Chdir(tmp); err != nil {
		return err
	}

	recordTypeToStringName, err := readMessageTypeTable()
	if err != nil {
		return err
	}

	recordTypeToNum, err := readRecordTypes()
	if err != nil {
		return err
	}

	numToRecordType := map[int]categorizationFields{}
	for recordType := range recordTypeToStringName {
		num, found := recordTypeToNum[recordType]
		if !found {
			return fmt.Errorf("missing definition of %v", recordType)
		}
		numToRecordType[num] = categorizationFieldFor(recordType, schema)
	}

	for recordType, num := range recordTypeToNum {
		// Do not replace existing mappings.
		if _, found := numToRecordType[num]; found {
			continue
		}
		numToRecordType[num] = categorizationFieldFor(recordType, schema)
	}

	// Create output file.
	f, err := os.Create(flagOut)
	if err != nil {
		return err
	}

	// Evaluate template.
	r := TemplateParams{
		Command:        filepath.Base(os.Args[0]),
		FieldsByNumber: numToRecordType,
	}
	if err := tmpl.Execute(f, r); err != nil {
		f.Close()
		return err
	}
	f.Close()

	if _, err := exec.Command("go", "fmt", flagOut).Output(); err != nil {
		return nil
	}

	return nil
}

var flagIn string
var flagOut string

func main() {
	flag.StringVar(&flagIn, "in", "ecs_categorization.yml", "input file")
	flag.StringVar(&flagOut, "out", "zecs_categorization.go", "output file")
	flag.Parse()

	var err error
	flagIn, err = filepath.Abs(flagIn)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
	flagOut, err = filepath.Abs(flagOut)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}
